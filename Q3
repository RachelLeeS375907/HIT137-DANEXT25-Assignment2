import turtle
import math

def setup_turtle():
    """
    Set up the turtle graphics window and turtle settings.
    Returns the turtle object.
    """
    # Create a screen
    screen = turtle.Screen()
    screen.setup(width=800, height=800)
    screen.bgcolor("white")
    screen.title("Recursive Geometric Pattern Generator")
    
    # Create and configure the turtle
    t = turtle.Turtle()
    t.speed(0)  # Fastest speed
    t.color("blue")
    t.width(1)
    
    return t, screen

def draw_recursive_edge(t, length, depth, angle=60):
    """
    Recursively draw an edge with indentations.
    
    Parameters:
    - t: turtle object
    - length: length of the current edge segment
    - depth: recursion depth (0 means draw straight line)
    - angle: angle for the indentation (60 degrees for equilateral triangle)
    """
    if depth == 0:
        # Base case: draw a straight line
        t.forward(length)
    else:
        # Recursive case: divide edge into 4 segments with indentation
        
        # Calculate the new segment length (1/3 of current length)
        new_length = length / 3
        
        # Draw first segment (straight)
        draw_recursive_edge(t, new_length, depth - 1, angle)
        
        # Turn inward and draw second segment (first side of indentation)
        t.right(angle)  # Turn right for inward indentation
        draw_recursive_edge(t, new_length, depth - 1, angle)
        
        # Draw third segment (second side of indentation)
        t.left(2 * angle)  # Turn to create the peak of the triangle
        draw_recursive_edge(t, new_length, depth - 1, angle)
        
        # Return to original direction and draw fourth segment
        t.right(angle)  # Turn back to original direction
        draw_recursive_edge(t, new_length, depth - 1, angle)

def draw_polygon_pattern(t, num_sides, side_length, depth):
    """
    Draw a polygon where each edge is recursively modified.
    
    Parameters:
    - t: turtle object
    - num_sides: number of sides in the polygon
    - side_length: length of each side
    - depth: recursion depth for the pattern
    """
    # Calculate the angle to turn for the polygon
    exterior_angle = 360 / num_sides
    
    # Draw each side of the polygon
    for i in range(num_sides):
        # Draw the recursive edge
        draw_recursive_edge(t, side_length, depth)
        
        # Turn to prepare for the next edge
        t.left(exterior_angle)

def position_turtle(t, num_sides, side_length):
    """
    Position the turtle to center the pattern on the screen.
    
    Parameters:
    - t: turtle object
    - num_sides: number of sides in the polygon
    - side_length: length of each side
    """
    # Calculate the radius of the polygon
    # For a regular polygon: radius = side_length / (2 * sin(Ï€/n))
    angle_rad = math.pi / num_sides
    radius = side_length / (2 * math.sin(angle_rad))
    
    # Move turtle to starting position without drawing
    t.penup()
    
    # Position based on polygon type
    if num_sides == 3:  # Triangle
        # Start from bottom left
        t.goto(-side_length/2, -radius/2)
        t.setheading(0)  # Face right
    elif num_sides == 4:  # Square
        # Start from top left corner
        t.goto(-side_length/2, side_length/2)
        t.setheading(0)  # Face right
    else:  # Other polygons
        # Start from a calculated position
        # Move to the leftmost vertex
        t.goto(-radius, 0)
        t.setheading(90 - (180 / num_sides))  # Adjust heading
    
    t.pendown()

def get_user_input():
    """
    Get input parameters from the user with validation.
    Returns tuple of (num_sides, side_length, depth)
    """
    print("=" * 50)
    print("Recursive Geometric Pattern Generator")
    print("=" * 50)
    print("\nThis program creates beautiful fractal patterns!")
    print("The pattern starts with a polygon and recursively")
    print("adds indentations to create intricate designs.\n")
    
    # Get number of sides
    while True:
        try:
            num_sides = int(input("Enter the number of sides (3-12): "))
            if 3 <= num_sides <= 12:
                break
            else:
                print("Please enter a number between 3 and 12.")
        except ValueError:
            print("Please enter a valid integer.")
    
    # Get side length
    while True:
        try:
            side_length = float(input("Enter the side length in pixels (50-400): "))
            if 50 <= side_length <= 400:
                break
            else:
                print("Please enter a length between 50 and 400 pixels.")
        except ValueError:
            print("Please enter a valid number.")
    
    # Get recursion depth
    while True:
        try:
            depth = int(input("Enter the recursion depth (0-5): "))
            if 0 <= depth <= 5:
                break
            else:
                print("Please enter a depth between 0 and 5.")
                print("(Higher values may take longer to draw)")
        except ValueError:
            print("Please enter a valid integer.")
    
    return num_sides, side_length, depth

def main():
    """
    Main function to run the pattern generator.
    """
    # Get user input
    num_sides, side_length, depth = get_user_input()
    
    print("\n" + "=" * 50)
    print(f"Drawing pattern with:")
    print(f"  - {num_sides} sides")
    print(f"  - Side length: {side_length} pixels")
    print(f"  - Recursion depth: {depth}")
    print("=" * 50)
    print("\nDrawing... (This may take a moment for complex patterns)")
    
    # Set up turtle
    t, screen = setup_turtle()
    
    # Position turtle for centered drawing
    position_turtle(t, num_sides, side_length)
    
    # Draw the pattern
    draw_polygon_pattern(t, num_sides, side_length, depth)
    
    # Hide the turtle and display result
    t.hideturtle()
    
    # Add text to show parameters
    t.penup()
    t.goto(0, -380)
    t.color("black")
    info_text = f"Sides: {num_sides}, Length: {side_length}, Depth: {depth}"
    t.write(info_text, align="center", font=("Arial", 12, "normal"))
    
    print("\nPattern complete!")
    print("Click on the window to close it.")
    
    # Keep window open until clicked
    screen.exitonclick()

if __name__ == "__main__":
    main()
