import os      # Operating system interface - used to check if folders/files exist
import csv     # CSV file reader - parses comma-separated value files
from datetime import datetime  # Date and time handling - for parsing dates and extracting months
import math    # Mathematical functions - specifically need sqrt for standard deviation

def load_all_csv_files(folder_path):
    """
    Load all CSV files from the temperatures folder and combine them.
    Returns a list of dictionaries with all temperature data.
    """
    # Create empty list to store all data from all files
    all_data = []
    
    # Check if the temperatures folder actually exists on the computer
    # os.path.exists returns True if folder exists, False otherwise
    if not os.path.exists(folder_path):
        print(f"Error: Folder '{folder_path}' not found!")
        return None  # Return None to indicate failure
    
    # Get list of all files in the folder
    # os.listdir returns a list of all filenames in the directory
    # List comprehension filters to only keep files ending with '.csv'
    csv_files = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
    
    # Check if we found any CSV files
    # Empty list evaluates to False in Python
    if not csv_files:
        print(f"No CSV files found in '{folder_path}'")
        return None
    
    # Tell user how many files we're about to process
    print(f"Found {len(csv_files)} CSV file(s) to process...")
    
    # Loop through each CSV file we found
    for file in csv_files:
        # Build complete path by joining folder path and filename
        # Example: "temperatures" + "2023.csv" = "temperatures/2023.csv"
        file_path = os.path.join(folder_path, file)
        
        try:
            # Open the CSV file in read mode
            # 'with' statement ensures file is properly closed after reading
            with open(file_path, 'r') as csvfile:
                # DictReader reads CSV and treats first row as column headers
                # Each row becomes a dictionary: {column_name: value}
                reader = csv.DictReader(csvfile)
                
                # Read each row from the CSV file
                for row in reader:
                    # Add this row (as a dictionary) to our main data list
                    all_data.append(row)
            
            # Report successful loading of this file
            print(f"  Loaded: {file}")
            
        except Exception as e:
            # If anything goes wrong reading the file, catch the error
            # Continue processing other files instead of crashing
            print(f"  Error loading {file}: {e}")
    
    # Return all collected data, or None if no data was loaded
    # Ternary operator: return all_data if it has content, else None
    return all_data if all_data else None

def find_column_name(data, possible_names):
    """
    Find which column name exists in the data from a list of possible names.
    """
    # Check if data is empty or None
    if not data:
        return None
    
    # Get column names from the first row (dictionary keys)
    # data[0] is first row, .keys() gets all column names
    columns = data[0].keys()
    
    # Try each possible name to see if it exists in the columns
    for name in possible_names:
        # If this name is found in the columns, return it
        if name in columns:
            return name
    
    # If none of the possible names were found, return None
    return None

def parse_date(date_string):
    """
    Try to parse a date string using common formats.
    Returns a datetime object or None if parsing fails.
    """
    # List of common date formats to try
    # %Y = 4-digit year, %m = month, %d = day
    date_formats = [
        '%Y-%m-%d',    # 2023-03-15
        '%d/%m/%Y',    # 15/03/2023
        '%m/%d/%Y',    # 03/15/2023
        '%Y/%m/%d',    # 2023/03/15
        '%d-%m-%Y',    # 15-03-2023
        '%m-%d-%Y'     # 03-15-2023
    ]
    
    # Try each format until one works
    for fmt in date_formats:
        try:
            # strptime converts string to datetime using the format
            # If successful, return the datetime object
            return datetime.strptime(date_string, fmt)
        except ValueError:
            # If format doesn't match, try the next one
            continue
    
    # If no format worked, return None
    return None

def get_season(month):
    """
    Determine the Australian season based on the month.
    Summer: Dec-Feb (12, 1, 2)
    Autumn: Mar-May (3, 4, 5)
    Winter: Jun-Aug (6, 7, 8)
    Spring: Sep-Nov (9, 10, 11)
    """
    # Check which list contains the month number
    # Australian seasons are opposite to Northern Hemisphere
    if month in [12, 1, 2]:     # December, January, February
        return "Summer"
    elif month in [3, 4, 5]:     # March, April, May
        return "Autumn"
    elif month in [6, 7, 8]:     # June, July, August
        return "Winter"
    elif month in [9, 10, 11]:   # September, October, November
        return "Spring"
    else:
        # Invalid month number (should never happen)
        return None

def is_valid_number(value):
    """
    Check if a value can be converted to a float and is not NaN.
    """
    # Check for None, empty string, or the text "NAN"
    # .upper() converts to uppercase for case-insensitive comparison
    if value is None or value == '' or value.upper() == 'NAN':
        return False
    
    try:
        # Try to convert the value to a float
        num = float(value)
        
        # Special check for NaN: NaN is the only value that's not equal to itself
        # This is a mathematical property of NaN in floating point
        if num != num:
            return False
        
        # Value is a valid number
        return True
        
    except (ValueError, TypeError):
        # Conversion failed - not a valid number
        return False

def calculate_mean(values):
    """
    Calculate the mean of a list of values.
    """
    # Check if list is empty
    if not values:
        return None
    
    # Mean = sum of all values divided by count
    # sum() adds all values, len() counts them
    return sum(values) / len(values)

def calculate_std_dev(values):
    """
    Calculate the standard deviation of a list of values.
    """
    # Need at least 2 values for standard deviation
    # With only 1 value, there's no variation to measure
    if len(values) < 2:
        return None
    
    # Step 1: Calculate the mean (average) of all values
    mean = calculate_mean(values)
    
    # Step 2: Calculate variance
    # For each value: subtract mean, square the result, then sum all
    # Divide by (n-1) for sample standard deviation (Bessel's correction)
    variance = sum((x - mean) ** 2 for x in values) / (len(values) - 1)
    
    # Step 3: Standard deviation is square root of variance
    return math.sqrt(variance)

def calculate_seasonal_averages(data):
    """
    Calculate the average temperature for each season across all stations and years.
    """
    print("\nCalculating seasonal averages...")
    
    # Find which column contains dates
    # Try common column names for dates
    date_columns = ['Date', 'date', 'DATE']
    date_col = find_column_name(data, date_columns)
    
    # If no date column found, we can't determine seasons
    if not date_col:
        print("Warning: No date column found. Cannot calculate seasonal averages.")
        return {}  # Return empty dictionary
    
    # Find which column contains temperatures
    # Try common column names for temperature
    temp_columns = ['Temperature', 'temperature', 'TEMPERATURE', 'Temp', 'temp']
    temp_col = find_column_name(data, temp_columns)
    
    # If no temperature column found, we can't calculate averages
    if not temp_col:
        print("Warning: No temperature column found.")
        return {}
    
    # Create dictionary to store temperature lists for each season
    # Each season starts with an empty list
    seasonal_temps = {
        'Summer': [],
        'Autumn': [],
        'Winter': [],
        'Spring': []
    }
    
    # Process each row of data
    for row in data:
        # Try to parse the date string into a datetime object
        date = parse_date(row[date_col])
        
        # Skip this row if date parsing failed
        if not date:
            continue
        
        # Get the season based on the month (1-12)
        season = get_season(date.month)
        
        # Skip if month was invalid (shouldn't happen)
        if not season:
            continue
        
        # Check if temperature value is valid (not NaN or empty)
        if is_valid_number(row[temp_col]):
            # Convert string to float and add to appropriate season list
            temp = float(row[temp_col])
            seasonal_temps[season].append(temp)
    
    # Calculate average for each season
    seasonal_avg = {}
    
    # Process each season's collected temperatures
    for season, temps in seasonal_temps.items():
        # Only calculate average if we have temperatures for this season
        if temps:
            # Calculate and store the mean temperature
            seasonal_avg[season] = calculate_mean(temps)
    
    return seasonal_avg

def find_largest_temperature_range(data):
    """
    Find the station(s) with the largest temperature range.
    """
    print("\nFinding stations with largest temperature range...")
    
    # Find column names for station and temperature
    # Try multiple possible column names
    station_columns = ['Station', 'station', 'STATION', 'Station_Name', 'station_name']
    temp_columns = ['Temperature', 'temperature', 'TEMPERATURE', 'Temp', 'temp']
    
    # Find actual column names in the data
    station_col = find_column_name(data, station_columns)
    temp_col = find_column_name(data, temp_columns)
    
    # Can't proceed without both columns
    if not station_col or not temp_col:
        print("Warning: Required columns not found.")
        return []  # Return empty list
    
    # Dictionary to group temperatures by station
    # Key: station name, Value: list of temperatures
    station_temps = {}
    
    # Process each row to group temperatures by station
    for row in data:
        # Get the station name from this row
        station = row[station_col]
        
        # Check if temperature is valid (not NaN)
        if is_valid_number(row[temp_col]):
            # Convert temperature to float
            temp = float(row[temp_col])
            
            # Create new list for this station if first time seeing it
            if station not in station_temps:
                station_temps[station] = []
            
            # Add temperature to this station's list
            station_temps[station].append(temp)
    
    # Dictionary to store range calculations for each station
    station_ranges = {}
    
    # Calculate temperature range for each station
    for station, temps in station_temps.items():
        # Only calculate if station has temperature data
        if temps:
            # Find highest and lowest temperatures
            max_temp = max(temps)  # Built-in max function
            min_temp = min(temps)  # Built-in min function
            
            # Calculate range (difference between max and min)
            temp_range = max_temp - min_temp
            
            # Store all three values for this station
            station_ranges[station] = {
                'range': temp_range,
                'max': max_temp,
                'min': min_temp
            }
    
    # Check if we have any stations with data
    if not station_ranges:
        return []
    
    # Find the largest range value
    # max() with key parameter finds dict with largest 'range' value
    max_range = max(station_ranges.values(), key=lambda x: x['range'])['range']
    
    # Find all stations that have this maximum range (handles ties)
    largest_range_stations = []
    
    # Check each station to see if it has the max range
    for station, data in station_ranges.items():
        # Use small tolerance (0.01) for floating point comparison
        if abs(data['range'] - max_range) < 0.01:
            # Add this station to results
            largest_range_stations.append({
                'station': station,
                'range': data['range'],
                'max': data['max'],
                'min': data['min']
            })
    
    return largest_range_stations

def calculate_temperature_stability(data):
    """
    Find stations with most stable (smallest std dev) and most variable (largest std dev) temperatures.
    """
    print("\nCalculating temperature stability...")
    
    # Find column names (same process as before)
    station_columns = ['Station', 'station', 'STATION', 'Station_Name', 'station_name']
    temp_columns = ['Temperature', 'temperature', 'TEMPERATURE', 'Temp', 'temp']
    
    # Get actual column names from data
    station_col = find_column_name(data, station_columns)
    temp_col = find_column_name(data, temp_columns)
    
    # Check both columns exist
    if not station_col or not temp_col:
        print("Warning: Required columns not found.")
        return [], []  # Return two empty lists
    
    # Group temperatures by station (same as before)
    station_temps = {}
    
    # Collect all temperatures for each station
    for row in data:
        station = row[station_col]
        
        # Only process valid temperature values
        if is_valid_number(row[temp_col]):
            temp = float(row[temp_col])
            
            # Initialize list for new station
            if station not in station_temps:
                station_temps[station] = []
            
            # Add to station's temperature list
            station_temps[station].append(temp)
    
    # Dictionary to store standard deviation for each station
    station_stdev = {}
    
    # Calculate standard deviation for each station
    for station, temps in station_temps.items():
        # Need at least 2 values to calculate standard deviation
        if len(temps) > 1:
            # Calculate and store if successful
            std_dev = calculate_std_dev(temps)
            if std_dev is not None:
                station_stdev[station] = std_dev
    
    # Check if we have any standard deviations calculated
    if not station_stdev:
        return [], []
    
    # Find the smallest and largest standard deviations
    min_stdev = min(station_stdev.values())  # Most stable
    max_stdev = max(station_stdev.values())  # Most variable
    
    # Lists to store results (handles ties)
    most_stable = []
    most_variable = []
    
    # Find all stations with min/max standard deviations
    for station, stdev in station_stdev.items():
        # Check if this station has the minimum stdev (most stable)
        if abs(stdev - min_stdev) < 0.01:
            most_stable.append({'station': station, 'stdev': stdev})
        
        # Check if this station has the maximum stdev (most variable)
        if abs(stdev - max_stdev) < 0.01:
            most_variable.append({'station': station, 'stdev': stdev})
    
    # Return both lists
    return most_stable, most_variable

def save_seasonal_averages(seasonal_avg, filename):
    """
    Save seasonal average temperatures to a text file.
    """
    print(f"\nSaving seasonal averages to {filename}...")
    
    # Open file in write mode ('w' creates new file or overwrites existing)
    with open(filename, 'w') as f:
        # Write header
        f.write("Seasonal Average Temperatures\n")
        
        # Write separator line (30 equal signs)
        f.write("=" * 30 + "\n\n")
        
        # Define the order we want seasons to appear
        season_order = ['Summer', 'Autumn', 'Winter', 'Spring']
        
        # Write each season's average in order
        for season in season_order:
            # Check if we have data for this season
            if season in seasonal_avg:
                # Format: "Season: XX.X°C" with 1 decimal place
                f.write(f"{season}: {seasonal_avg[season]:.1f}°C\n")
    
    # Confirm file was saved
    print(f"  Saved to {filename}")

def save_largest_range(stations, filename):
    """
    Save stations with largest temperature range to a text file.
    """
    print(f"\nSaving largest temperature range to {filename}...")
    
    # Open file for writing
    with open(filename, 'w') as f:
        # Write header
        f.write("Station(s) with Largest Temperature Range\n")
        
        # Write separator line (40 equal signs)
        f.write("=" * 40 + "\n\n")
        
        # Check if we have any stations to write
        if stations:
            # Write each station's data
            for station_data in stations:
                # First part: "Station ABC: "
                f.write(f"Station {station_data['station']}: ")
                
                # Second part: "Range XX.X°C "
                f.write(f"Range {station_data['range']:.1f}°C ")
                
                # Third part: "(Max: XX.X°C, Min: XX.X°C)"
                f.write(f"(Max: {station_data['max']:.1f}°C, ")
                f.write(f"Min: {station_data['min']:.1f}°C)\n")
        else:
            # No data case
            f.write("No data available\n")
    
    print(f"  Saved to {filename}")

def save_stability_results(most_stable, most_variable, filename):
    """
    Save temperature stability results to a text file.
    """
    print(f"\nSaving temperature stability to {filename}...")
    
    # Open file for writing
    with open(filename, 'w') as f:
        # Write header
        f.write("Temperature Stability Analysis\n")
        f.write("=" * 30 + "\n\n")
        
        # Section 1: Most stable stations
        f.write("Most Stable Station(s):\n")
        
        # Check if we have stable station data
        if most_stable:
            # Write each stable station
            for station_data in most_stable:
                f.write(f"Most Stable: Station {station_data['station']}: ")
                
                # Format standard deviation with 1 decimal place
                f.write(f"StdDev {station_data['stdev']:.1f}°C\n")
        else:
            f.write("No data available\n")
        
        # Section 2: Most variable stations (with blank line before)
        f.write("\nMost Variable Station(s):\n")
        
        # Check if we have variable station data
        if most_variable:
            # Write each variable station
            for station_data in most_variable:
                f.write(f"Most Variable: Station {station_data['station']}: ")
                f.write(f"StdDev {station_data['stdev']:.1f}°C\n")
        else:
            f.write("No data available\n")
    
    print(f"  Saved to {filename}")

def main():
    """
    Main function to run all analyses.
    """
    # Print program header with decorative lines
    print("=" * 50)
    print("Australian Weather Station Temperature Analysis")
    print("=" * 50)
    
    # Define the folder containing CSV files
    folder_path = "temperatures"
    
    # Load all CSV files from the folder
    data = load_all_csv_files(folder_path)
    
    # Check if data was successfully loaded
    if data is None:
        print("Error: Could not load data. Exiting.")
        return  # Exit the program
    
    # Print summary of loaded data
    print(f"\nTotal records loaded: {len(data)}")
    
    # Show column names from first row (if data exists)
    if data:
        print(f"Columns found: {list(data[0].keys())}")
    
    # Task 1: Calculate seasonal averages
    # Call function and get dictionary of averages
    seasonal_avg = calculate_seasonal_averages(data)
    
    # Save results if we got any averages
    if seasonal_avg:
        save_seasonal_averages(seasonal_avg, "average_temp.txt")
    
    # Task 2: Find largest temperature range
    # Get list of stations with largest range
    largest_range = find_largest_temperature_range(data)
    
    # Save results (even if empty list)
    save_largest_range(largest_range, "largest_temp_range_station.txt")
    
    # Task 3: Calculate temperature stability
    # Get two lists: most stable and most variable stations
    most_stable, most_variable = calculate_temperature_stability(data)
    
    # Save both results to one file
    save_stability_results(most_stable, most_variable, "temperature_stability_stations.txt")
    
    # Print completion message with file list
    print("\n" + "=" * 50)
    print("Analysis complete! Check the output files:")
    print("  - average_temp.txt")
    print("  - largest_temp_range_station.txt")
    print("  - temperature_stability_stations.txt")
    print("=" * 50)

# Standard Python idiom: only run main() if script is run directly
# (not imported as a module)
if __name__ == "__main__":
    main()
